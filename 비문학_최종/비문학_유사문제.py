# -*- coding: utf-8 -*-
"""비문학_유사문제

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K63NHRBnQpWe4z5KKk_ffH8dJCXg53eJ

## 기본 install
"""

from google.colab import drive
drive.mount('/content/drive')

!pip install pytesseract PyPDF2

!pip install pdfplumber pdf2image

# Install Poppler utilities
!sudo apt-get update
!sudo apt-get install -y poppler-utils

import os
os.environ["OPENAI_API_KEY"] = "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"

!pip install faiss-cpu

import os
import base64
from PIL import Image
from IPython.display import display
from openai import OpenAI

"""## GPT 태깅 프롬프트"""

import os
from openai import OpenAI

client = OpenAI(api_key=os.environ["OPENAI_API_KEY"])

tag_prompt = """
아래는 국어 영역 비문학 문제입니다.
이 문제에 대해 다음 정보를 태그로 생성해 주세요(최대 6개):
- 출제 영역(비문학)
- 세부 분야(인문-철학/논리/언어/역사, 사회-정치/법/경제/사회/문화, 과학-물리/화학/생물/지구과학, 기술-컴퓨터/기계/응용/실용, 예술-미술/음악/건축/공연, 융합)
- 문제 유형(단일문제/복합문제)
- 주요 주제 또는 키워드

지문이 (가), (나)로 이루어지면 복합문제입니다.

태그는 쉼표로 구분해서 출력해 주세요.
예) 비문학, 사회-경제, 복합문제, 공공재, 정책 딜레마, 지방 정부 재정 지원

문제:
{text}
"""

def generate_tags_from_passage(passage):
    prompt = tag_prompt.format(text=passage)
    response = client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": "너는 국어 문제 태깅 전문가야."},
            {"role": "user", "content": prompt}
        ],
        temperature=0.2
    )
    tag_line = response.choices[0].message.content.strip()

    tags = [tag.strip() for tag in tag_line.split(",") if tag.strip()]

    return {
        "passage": passage,
        "genre": tags[1],
        "question_type": "복합문제" if "복합" in tags[2] else "단일문제",
        "keywords": tags[3:],
    }

"""## 임베딩 & 유사문제 추천"""

!pip install easyocr

from sklearn.metrics.pairwise import cosine_similarity
from sentence_transformers import SentenceTransformer
import numpy as np
import json

# 1. 모델과 데이터 준비
print("모델과 데이터 불러오는 중...")
model = SentenceTransformer("jhgan/ko-sroberta-multitask")

with open("/content/drive/MyDrive/STUBO/non-literature_cleaned.json", encoding="utf-8") as f:
    data = json.load(f)

passages = [item["passage"] for item in data]
embeddings = model.encode(passages, convert_to_tensor=False)  # 전체 지문 임베딩 (고정)

print("초기화 완료!")

# 2. 유사 문제 추천 함수 (키워드 → 코사인 유사도)
def recommend_for_external_problem(target_problem, top_n=2):
    target_passage = target_problem["passage"]
    target_keywords = target_problem["keywords"]
    target_type = target_problem["question_type"]
    target_genre = target_problem["genre"]

    # 지문 임베딩
    target_embedding = model.encode(target_passage, convert_to_tensor=False)
    passage_similarities = cosine_similarity([target_embedding], embeddings)[0]

    # 키워드 문자열 임베딩
    target_kw_string = " ".join(target_keywords)
    target_kw_embedding = model.encode(target_kw_string, convert_to_tensor=False)

    results = []
    for idx, item in enumerate(data):
        # 필터 1: 문제 장르 일치
        if item["genre"] != target_genre:
            continue

        # 필터 2: 키워드 유사도
        item_kw_string = " ".join(item["keywords"])
        item_kw_embedding = model.encode(item_kw_string, convert_to_tensor=False)
        keyword_sim = cosine_similarity([target_kw_embedding], [item_kw_embedding])[0][0]

        # 필터 3: 지문 유사도
        passage_sim = passage_similarities[idx]

        # 기본 점수 계산
        final_score = 0.5 * keyword_sim + 0.5 * passage_sim

        # 🔹 보정 점수 추가: 문제 유형이 일치하면
        if item["question_type"] == target_type:
            final_score += 0.2

        # 결과 저장
        results.append({
            "year": item["year"],
            "month": item["month"],
            "pNum": item["pNum"],
            "start_Qnum": item.get("start_Qnum"),
            "end_Qnum": item.get("end_Qnum"),
            "score": round(final_score, 4),
            "keyword_cosine": round(keyword_sim, 4),
            "embedding_sim": round(passage_sim, 4),
            "preview": item["passage"][:100]
        })

    results = sorted(results, key=lambda x: x["score"], reverse=True)[:top_n]
    return results

# STEP 1: GPT로 태깅
def tag_from_image(image_path):
    with open(image_path, "rb") as image_file:
        base64_image = base64.b64encode(image_file.read()).decode("utf-8")

    client = OpenAI(api_key=os.environ["OPENAI_API_KEY"])

    response = client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": "너는 국어 문제 태깅 전문가야."},
            {
                "role": "user",
                "content": [
                    {"type": "text", "text": "이 국어 지문 이미지를 보고, 아래 기준에 따라 태그를 생성해 줘:\n" + tag_prompt +
                       """ \n 지문 분량과 키워드와 상관 없이 (가), (나) 등으로 이루어져있지 않으면 무조건 단일 문제야.
                          그리고 여기 안에서 장르를 분류해줘('인문-언어', '인문-철학', '사회-경제', '기술-컴퓨터', '사회-법', '과학-생물', '인문-역사', '과학-화학', '인문-심리', '예술-미술', '과학-물리', '사회-정치', '예술-음악', '예술-영화')"""},
                    {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"}}
                ]
            }
        ],
        temperature=0.2
    )

    tags = response.choices[0].message.content.strip().split(",")
    tags = [t.strip() for t in tags if t.strip()]

    #print("\n[자동 태깅 결과]")
    #print("GPT 응답:", ", ".join(tags))

    return {
        "passage": "[이미지 기반 지문 생략]",
        "genre": tags[1],
        "question_type": "복합문제" if "복합" in tags[2] else "단일문제",
        "keywords": tags[2:-1],  # 문제번호 제외
    }

import os
from PIL import Image
from IPython.display import display

def show_problem_image_set(similar_problems, image_base="/content/drive/MyDrive/classified_images/비문학"):
    for i, p in enumerate(similar_problems, 1):
        year = p.get('year', '정보 없음')
        month = p.get('month', '정보 없음')
        pNum = p.get('pNum', '정보 없음')
        start_Q = p.get('start_Qnum', None)
        end_Q = p.get('end_Qnum', None)

        print(f"\n--- 유사 문제 {i} ---")
        print("\n")
        print(f"{year}-{month}")
        img_filename = f"{year}-{month}-국어_p{pNum}.png"
        img_path = os.path.join(image_base, img_filename)
        img = Image.open(img_path)
        display(img)

        if year == '정보 없음' or month == '정보 없음' or start_Q is None or end_Q is None:
            print("[경고] start_Qnum 또는 end_Qnum 정보가 없습니다. 이미지를 출력할 수 없습니다.")
            continue

        for q_num in range(start_Q, end_Q + 1):
            image_filename = f"{year}-{month}-국어_{q_num}.png"
            image_path = os.path.join(image_base, image_filename)

            #print(f"[문제 {q_num}] 이미지 파일: {image_filename}", end=' ')
            if os.path.exists(image_path):
                #print("→ 존재")
                image = Image.open(image_path)
                display(image)
                print("\n")
            #else:
                #print("→ 없음 (파일이 존재하지 않음)")

import os

# 1. 테스트할 이미지 파일명
image_name = "1_단일_동형이의어.png"

# 2. 폴더 경로
folder_path = "/content/drive/MyDrive/유사test"
image_path = os.path.join(folder_path, image_name)

# 3. 존재 여부 확인
if not os.path.exists(image_path):
    print(f"❌ 이미지가 존재하지 않습니다: {image_path}")
else:
    print(f"\n=== 이미지: {image_name} ===")
    img = Image.open(image_path)
    display(img)

    # 4. GPT Vision으로 태깅
    external_problem = tag_from_image(image_path)

    # 5. 유사 문제 추천
    print("\n\n[유사 문제 추천 결과]")
    similar_problems = recommend_for_external_problem(external_problem)

    # 6. 추천된 문제 이미지 표시
    if similar_problems:
        show_problem_image_set(similar_problems)
    else:
        print("최근에 출제된 유사한 기출 문제가 없습니다.")